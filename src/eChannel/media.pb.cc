// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: media.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "media.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace MGC {

void protobuf_ShutdownFile_media_2eproto() {
  delete Register::default_instance_;
  delete RegisterResp::default_instance_;
  delete TurnRelay::default_instance_;
  delete Candidates::default_instance_;
  delete Candidates_Candidate::default_instance_;
  delete InviteReq::default_instance_;
  delete InviteResp::default_instance_;
  delete TurnReq::default_instance_;
  delete TurnResp::default_instance_;
  delete ByeReq::default_instance_;
  delete ByeResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_media_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_media_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Register::default_instance_ = new Register();
  RegisterResp::default_instance_ = new RegisterResp();
  TurnRelay::default_instance_ = new TurnRelay();
  Candidates::default_instance_ = new Candidates();
  Candidates_Candidate::default_instance_ = new Candidates_Candidate();
  InviteReq::default_instance_ = new InviteReq();
  InviteResp::default_instance_ = new InviteResp();
  TurnReq::default_instance_ = new TurnReq();
  TurnResp::default_instance_ = new TurnResp();
  ByeReq::default_instance_ = new ByeReq();
  ByeResp::default_instance_ = new ByeResp();
  Register::default_instance_->InitAsDefaultInstance();
  RegisterResp::default_instance_->InitAsDefaultInstance();
  TurnRelay::default_instance_->InitAsDefaultInstance();
  Candidates::default_instance_->InitAsDefaultInstance();
  Candidates_Candidate::default_instance_->InitAsDefaultInstance();
  InviteReq::default_instance_->InitAsDefaultInstance();
  InviteResp::default_instance_->InitAsDefaultInstance();
  TurnReq::default_instance_->InitAsDefaultInstance();
  TurnResp::default_instance_->InitAsDefaultInstance();
  ByeReq::default_instance_->InitAsDefaultInstance();
  ByeResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_media_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_media_2eproto_once_);
void protobuf_AddDesc_media_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_media_2eproto_once_,
                 &protobuf_AddDesc_media_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_media_2eproto {
  StaticDescriptorInitializer_media_2eproto() {
    protobuf_AddDesc_media_2eproto();
  }
} static_descriptor_initializer_media_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Register::kFromFieldNumber;
const int Register::kExpireFieldNumber;
const int Register::kAuthFieldNumber;
#endif  // !_MSC_VER

Register::Register()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Register::InitAsDefaultInstance() {
}

Register::Register(const Register& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Register::SharedCtor() {
  _cached_size_ = 0;
  from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  expire_ = 0u;
  auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Register::~Register() {
  SharedDtor();
}

void Register::SharedDtor() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Register::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Register& Register::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

Register* Register::default_instance_ = NULL;

Register* Register::New() const {
  return new Register;
}

void Register::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != &::google::protobuf::internal::kEmptyString) {
        from_->clear();
      }
    }
    expire_ = 0u;
    if (has_auth()) {
      if (auth_ != &::google::protobuf::internal::kEmptyString) {
        auth_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Register::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_expire;
        break;
      }

      // optional uint32 expire = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expire:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expire_)));
          set_has_expire();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_auth;
        break;
      }

      // optional string auth = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_auth()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Register::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from(), output);
  }

  // optional uint32 expire = 2;
  if (has_expire()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->expire(), output);
  }

  // optional string auth = 3;
  if (has_auth()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->auth(), output);
  }

}

int Register::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from());
    }

    // optional uint32 expire = 2;
    if (has_expire()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expire());
    }

    // optional string auth = 3;
    if (has_auth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->auth());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Register::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Register*>(&from));
}

void Register::MergeFrom(const Register& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      set_from(from.from());
    }
    if (from.has_expire()) {
      set_expire(from.expire());
    }
    if (from.has_auth()) {
      set_auth(from.auth());
    }
  }
}

void Register::CopyFrom(const Register& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Register::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Register::Swap(Register* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(expire_, other->expire_);
    std::swap(auth_, other->auth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Register::GetTypeName() const {
  return "MGC.Register";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterResp::kFromFieldNumber;
const int RegisterResp::kCodeFieldNumber;
const int RegisterResp::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

RegisterResp::RegisterResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterResp::InitAsDefaultInstance() {
}

RegisterResp::RegisterResp(const RegisterResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterResp::SharedCtor() {
  _cached_size_ = 0;
  from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  code_ = 0u;
  privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterResp::~RegisterResp() {
  SharedDtor();
}

void RegisterResp::SharedDtor() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterResp& RegisterResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

RegisterResp* RegisterResp::default_instance_ = NULL;

RegisterResp* RegisterResp::New() const {
  return new RegisterResp;
}

void RegisterResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != &::google::protobuf::internal::kEmptyString) {
        from_->clear();
      }
    }
    code_ = 0u;
    if (has_privatekey()) {
      if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
        privatekey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required uint32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_privateKey;
        break;
      }

      // optional string privateKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_privateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_privatekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from(), output);
  }

  // required uint32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->code(), output);
  }

  // optional string privateKey = 3;
  if (has_privatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->privatekey(), output);
  }

}

int RegisterResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from());
    }

    // required uint32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

    // optional string privateKey = 3;
    if (has_privatekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->privatekey());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterResp*>(&from));
}

void RegisterResp::MergeFrom(const RegisterResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      set_from(from.from());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_privatekey()) {
      set_privatekey(from.privatekey());
    }
  }
}

void RegisterResp::CopyFrom(const RegisterResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RegisterResp::Swap(RegisterResp* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(code_, other->code_);
    std::swap(privatekey_, other->privatekey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterResp::GetTypeName() const {
  return "MGC.RegisterResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TurnRelay::kAddrFieldNumber;
const int TurnRelay::kPortFieldNumber;
#endif  // !_MSC_VER

TurnRelay::TurnRelay()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TurnRelay::InitAsDefaultInstance() {
}

TurnRelay::TurnRelay(const TurnRelay& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TurnRelay::SharedCtor() {
  _cached_size_ = 0;
  addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TurnRelay::~TurnRelay() {
  SharedDtor();
}

void TurnRelay::SharedDtor() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TurnRelay::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TurnRelay& TurnRelay::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

TurnRelay* TurnRelay::default_instance_ = NULL;

TurnRelay* TurnRelay::New() const {
  return new TurnRelay;
}

void TurnRelay::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_addr()) {
      if (addr_ != &::google::protobuf::internal::kEmptyString) {
        addr_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TurnRelay::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string addr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_addr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TurnRelay::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string addr = 1;
  if (has_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->addr(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

}

int TurnRelay::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string addr = 1;
    if (has_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->addr());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TurnRelay::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TurnRelay*>(&from));
}

void TurnRelay::MergeFrom(const TurnRelay& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_addr()) {
      set_addr(from.addr());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void TurnRelay::CopyFrom(const TurnRelay& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnRelay::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TurnRelay::Swap(TurnRelay* other) {
  if (other != this) {
    std::swap(addr_, other->addr_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TurnRelay::GetTypeName() const {
  return "MGC.TurnRelay";
}


// ===================================================================

#ifndef _MSC_VER
const int Candidates_Candidate::kAddrFieldNumber;
const int Candidates_Candidate::kPortFieldNumber;
#endif  // !_MSC_VER

Candidates_Candidate::Candidates_Candidate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Candidates_Candidate::InitAsDefaultInstance() {
}

Candidates_Candidate::Candidates_Candidate(const Candidates_Candidate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Candidates_Candidate::SharedCtor() {
  _cached_size_ = 0;
  addr_ = 0u;
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Candidates_Candidate::~Candidates_Candidate() {
  SharedDtor();
}

void Candidates_Candidate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Candidates_Candidate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Candidates_Candidate& Candidates_Candidate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

Candidates_Candidate* Candidates_Candidate::default_instance_ = NULL;

Candidates_Candidate* Candidates_Candidate::New() const {
  return new Candidates_Candidate;
}

void Candidates_Candidate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    addr_ = 0u;
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Candidates_Candidate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 addr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &addr_)));
          set_has_addr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Candidates_Candidate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 addr = 1;
  if (has_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->addr(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

}

int Candidates_Candidate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 addr = 1;
    if (has_addr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->addr());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Candidates_Candidate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Candidates_Candidate*>(&from));
}

void Candidates_Candidate::MergeFrom(const Candidates_Candidate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_addr()) {
      set_addr(from.addr());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void Candidates_Candidate::CopyFrom(const Candidates_Candidate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Candidates_Candidate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Candidates_Candidate::Swap(Candidates_Candidate* other) {
  if (other != this) {
    std::swap(addr_, other->addr_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Candidates_Candidate::GetTypeName() const {
  return "MGC.Candidates.Candidate";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Candidates::kNatFieldNumber;
const int Candidates::kAddrsFieldNumber;
#endif  // !_MSC_VER

Candidates::Candidates()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Candidates::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  nat_ = const_cast< ::MGC::Candidates_Candidate*>(
      ::MGC::Candidates_Candidate::internal_default_instance());
#else
  nat_ = const_cast< ::MGC::Candidates_Candidate*>(&::MGC::Candidates_Candidate::default_instance());
#endif
}

Candidates::Candidates(const Candidates& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Candidates::SharedCtor() {
  _cached_size_ = 0;
  nat_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Candidates::~Candidates() {
  SharedDtor();
}

void Candidates::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete nat_;
  }
}

void Candidates::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Candidates& Candidates::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

Candidates* Candidates::default_instance_ = NULL;

Candidates* Candidates::New() const {
  return new Candidates;
}

void Candidates::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_nat()) {
      if (nat_ != NULL) nat_->::MGC::Candidates_Candidate::Clear();
    }
  }
  addrs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Candidates::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MGC.Candidates.Candidate nat = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_addrs;
        break;
      }

      // repeated .MGC.Candidates.Candidate addrs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_addrs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_addrs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_addrs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Candidates::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .MGC.Candidates.Candidate nat = 1;
  if (has_nat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->nat(), output);
  }

  // repeated .MGC.Candidates.Candidate addrs = 2;
  for (int i = 0; i < this->addrs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->addrs(i), output);
  }

}

int Candidates::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MGC.Candidates.Candidate nat = 1;
    if (has_nat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nat());
    }

  }
  // repeated .MGC.Candidates.Candidate addrs = 2;
  total_size += 1 * this->addrs_size();
  for (int i = 0; i < this->addrs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->addrs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Candidates::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Candidates*>(&from));
}

void Candidates::MergeFrom(const Candidates& from) {
  GOOGLE_CHECK_NE(&from, this);
  addrs_.MergeFrom(from.addrs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nat()) {
      mutable_nat()->::MGC::Candidates_Candidate::MergeFrom(from.nat());
    }
  }
}

void Candidates::CopyFrom(const Candidates& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Candidates::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_nat()) {
    if (!this->nat().IsInitialized()) return false;
  }
  for (int i = 0; i < addrs_size(); i++) {
    if (!this->addrs(i).IsInitialized()) return false;
  }
  return true;
}

void Candidates::Swap(Candidates* other) {
  if (other != this) {
    std::swap(nat_, other->nat_);
    addrs_.Swap(&other->addrs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Candidates::GetTypeName() const {
  return "MGC.Candidates";
}


// ===================================================================

#ifndef _MSC_VER
const int InviteReq::kFromFieldNumber;
const int InviteReq::kToFieldNumber;
const int InviteReq::kSuuidFieldNumber;
const int InviteReq::kMediaAddrsFieldNumber;
const int InviteReq::kMediaFieldNumber;
const int InviteReq::kMediaInfoFieldNumber;
const int InviteReq::kTransportFieldNumber;
const int InviteReq::kTurnaddrFieldNumber;
#endif  // !_MSC_VER

InviteReq::InviteReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void InviteReq::InitAsDefaultInstance() {
}

InviteReq::InviteReq(const InviteReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void InviteReq::SharedCtor() {
  _cached_size_ = 0;
  from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mediaaddrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  media_ = 0u;
  mediainfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transport_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InviteReq::~InviteReq() {
  SharedDtor();
}

void InviteReq::SharedDtor() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    delete suuid_;
  }
  if (mediaaddrs_ != &::google::protobuf::internal::kEmptyString) {
    delete mediaaddrs_;
  }
  if (mediainfo_ != &::google::protobuf::internal::kEmptyString) {
    delete mediainfo_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InviteReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InviteReq& InviteReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

InviteReq* InviteReq::default_instance_ = NULL;

InviteReq* InviteReq::New() const {
  return new InviteReq;
}

void InviteReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != &::google::protobuf::internal::kEmptyString) {
        from_->clear();
      }
    }
    if (has_to()) {
      if (to_ != &::google::protobuf::internal::kEmptyString) {
        to_->clear();
      }
    }
    if (has_suuid()) {
      if (suuid_ != &::google::protobuf::internal::kEmptyString) {
        suuid_->clear();
      }
    }
    if (has_mediaaddrs()) {
      if (mediaaddrs_ != &::google::protobuf::internal::kEmptyString) {
        mediaaddrs_->clear();
      }
    }
    media_ = 0u;
    if (has_mediainfo()) {
      if (mediainfo_ != &::google::protobuf::internal::kEmptyString) {
        mediainfo_->clear();
      }
    }
    transport_ = 0u;
  }
  turnaddr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool InviteReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // required string to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_suuid;
        break;
      }

      // required string suuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_suuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_suuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_mediaAddrs;
        break;
      }

      // optional string mediaAddrs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mediaAddrs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mediaaddrs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_media;
        break;
      }

      // optional uint32 media = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_media:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &media_)));
          set_has_media();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_mediaInfo;
        break;
      }

      // optional string mediaInfo = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mediaInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mediainfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_transport;
        break;
      }

      // optional uint32 transport = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transport:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transport_)));
          set_has_transport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_turnaddr;
        break;
      }

      // repeated .MGC.TurnRelay turnaddr = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_turnaddr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_turnaddr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_turnaddr;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InviteReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from(), output);
  }

  // required string to = 2;
  if (has_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->to(), output);
  }

  // required string suuid = 3;
  if (has_suuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->suuid(), output);
  }

  // optional string mediaAddrs = 4;
  if (has_mediaaddrs()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->mediaaddrs(), output);
  }

  // optional uint32 media = 5;
  if (has_media()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->media(), output);
  }

  // optional string mediaInfo = 6;
  if (has_mediainfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->mediainfo(), output);
  }

  // optional uint32 transport = 7;
  if (has_transport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->transport(), output);
  }

  // repeated .MGC.TurnRelay turnaddr = 8;
  for (int i = 0; i < this->turnaddr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->turnaddr(i), output);
  }

}

int InviteReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from());
    }

    // required string to = 2;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to());
    }

    // required string suuid = 3;
    if (has_suuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->suuid());
    }

    // optional string mediaAddrs = 4;
    if (has_mediaaddrs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mediaaddrs());
    }

    // optional uint32 media = 5;
    if (has_media()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->media());
    }

    // optional string mediaInfo = 6;
    if (has_mediainfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mediainfo());
    }

    // optional uint32 transport = 7;
    if (has_transport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->transport());
    }

  }
  // repeated .MGC.TurnRelay turnaddr = 8;
  total_size += 1 * this->turnaddr_size();
  for (int i = 0; i < this->turnaddr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->turnaddr(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InviteReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InviteReq*>(&from));
}

void InviteReq::MergeFrom(const InviteReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  turnaddr_.MergeFrom(from.turnaddr_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      set_from(from.from());
    }
    if (from.has_to()) {
      set_to(from.to());
    }
    if (from.has_suuid()) {
      set_suuid(from.suuid());
    }
    if (from.has_mediaaddrs()) {
      set_mediaaddrs(from.mediaaddrs());
    }
    if (from.has_media()) {
      set_media(from.media());
    }
    if (from.has_mediainfo()) {
      set_mediainfo(from.mediainfo());
    }
    if (from.has_transport()) {
      set_transport(from.transport());
    }
  }
}

void InviteReq::CopyFrom(const InviteReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InviteReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  for (int i = 0; i < turnaddr_size(); i++) {
    if (!this->turnaddr(i).IsInitialized()) return false;
  }
  return true;
}

void InviteReq::Swap(InviteReq* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(to_, other->to_);
    std::swap(suuid_, other->suuid_);
    std::swap(mediaaddrs_, other->mediaaddrs_);
    std::swap(media_, other->media_);
    std::swap(mediainfo_, other->mediainfo_);
    std::swap(transport_, other->transport_);
    turnaddr_.Swap(&other->turnaddr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string InviteReq::GetTypeName() const {
  return "MGC.InviteReq";
}


// ===================================================================

#ifndef _MSC_VER
const int InviteResp::kRequestFieldNumber;
const int InviteResp::kCodeFieldNumber;
#endif  // !_MSC_VER

InviteResp::InviteResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void InviteResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  request_ = const_cast< ::MGC::InviteReq*>(
      ::MGC::InviteReq::internal_default_instance());
#else
  request_ = const_cast< ::MGC::InviteReq*>(&::MGC::InviteReq::default_instance());
#endif
}

InviteResp::InviteResp(const InviteResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void InviteResp::SharedCtor() {
  _cached_size_ = 0;
  request_ = NULL;
  code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InviteResp::~InviteResp() {
  SharedDtor();
}

void InviteResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete request_;
  }
}

void InviteResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InviteResp& InviteResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

InviteResp* InviteResp::default_instance_ = NULL;

InviteResp* InviteResp::New() const {
  return new InviteResp;
}

void InviteResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_request()) {
      if (request_ != NULL) request_->::MGC::InviteReq::Clear();
    }
    code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool InviteResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MGC.InviteReq request = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required uint32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InviteResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .MGC.InviteReq request = 1;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->request(), output);
  }

  // required uint32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->code(), output);
  }

}

int InviteResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MGC.InviteReq request = 1;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

    // required uint32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InviteResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InviteResp*>(&from));
}

void InviteResp::MergeFrom(const InviteResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request()) {
      mutable_request()->::MGC::InviteReq::MergeFrom(from.request());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void InviteResp::CopyFrom(const InviteResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InviteResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_request()) {
    if (!this->request().IsInitialized()) return false;
  }
  return true;
}

void InviteResp::Swap(InviteResp* other) {
  if (other != this) {
    std::swap(request_, other->request_);
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string InviteResp::GetTypeName() const {
  return "MGC.InviteResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TurnReq::kUuidFieldNumber;
const int TurnReq::kFromFieldNumber;
#endif  // !_MSC_VER

TurnReq::TurnReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TurnReq::InitAsDefaultInstance() {
}

TurnReq::TurnReq(const TurnReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TurnReq::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TurnReq::~TurnReq() {
  SharedDtor();
}

void TurnReq::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TurnReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TurnReq& TurnReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

TurnReq* TurnReq::default_instance_ = NULL;

TurnReq* TurnReq::New() const {
  return new TurnReq;
}

void TurnReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_from()) {
      if (from_ != &::google::protobuf::internal::kEmptyString) {
        from_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TurnReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_from;
        break;
      }

      // required string from = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TurnReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }

  // required string from = 2;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->from(), output);
  }

}

int TurnReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // required string from = 2;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TurnReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TurnReq*>(&from));
}

void TurnReq::MergeFrom(const TurnReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_from()) {
      set_from(from.from());
    }
  }
}

void TurnReq::CopyFrom(const TurnReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TurnReq::Swap(TurnReq* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(from_, other->from_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TurnReq::GetTypeName() const {
  return "MGC.TurnReq";
}


// ===================================================================

#ifndef _MSC_VER
const int TurnResp::kRequestFieldNumber;
const int TurnResp::kCodeFieldNumber;
const int TurnResp::kTrunIpFieldNumber;
const int TurnResp::kTrunChannelFieldNumber;
#endif  // !_MSC_VER

TurnResp::TurnResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TurnResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  request_ = const_cast< ::MGC::TurnReq*>(
      ::MGC::TurnReq::internal_default_instance());
#else
  request_ = const_cast< ::MGC::TurnReq*>(&::MGC::TurnReq::default_instance());
#endif
}

TurnResp::TurnResp(const TurnResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TurnResp::SharedCtor() {
  _cached_size_ = 0;
  request_ = NULL;
  code_ = 0u;
  trunip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trunchannel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TurnResp::~TurnResp() {
  SharedDtor();
}

void TurnResp::SharedDtor() {
  if (trunip_ != &::google::protobuf::internal::kEmptyString) {
    delete trunip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete request_;
  }
}

void TurnResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TurnResp& TurnResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

TurnResp* TurnResp::default_instance_ = NULL;

TurnResp* TurnResp::New() const {
  return new TurnResp;
}

void TurnResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_request()) {
      if (request_ != NULL) request_->::MGC::TurnReq::Clear();
    }
    code_ = 0u;
    if (has_trunip()) {
      if (trunip_ != &::google::protobuf::internal::kEmptyString) {
        trunip_->clear();
      }
    }
    trunchannel_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TurnResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MGC.TurnReq request = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required uint32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_TrunIp;
        break;
      }

      // optional string TrunIp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TrunIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trunip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_TrunChannel;
        break;
      }

      // optional uint32 TrunChannel = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TrunChannel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trunchannel_)));
          set_has_trunchannel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TurnResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .MGC.TurnReq request = 1;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->request(), output);
  }

  // required uint32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->code(), output);
  }

  // optional string TrunIp = 3;
  if (has_trunip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->trunip(), output);
  }

  // optional uint32 TrunChannel = 4;
  if (has_trunchannel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->trunchannel(), output);
  }

}

int TurnResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MGC.TurnReq request = 1;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

    // required uint32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

    // optional string TrunIp = 3;
    if (has_trunip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trunip());
    }

    // optional uint32 TrunChannel = 4;
    if (has_trunchannel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trunchannel());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TurnResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TurnResp*>(&from));
}

void TurnResp::MergeFrom(const TurnResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request()) {
      mutable_request()->::MGC::TurnReq::MergeFrom(from.request());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_trunip()) {
      set_trunip(from.trunip());
    }
    if (from.has_trunchannel()) {
      set_trunchannel(from.trunchannel());
    }
  }
}

void TurnResp::CopyFrom(const TurnResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TurnResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_request()) {
    if (!this->request().IsInitialized()) return false;
  }
  return true;
}

void TurnResp::Swap(TurnResp* other) {
  if (other != this) {
    std::swap(request_, other->request_);
    std::swap(code_, other->code_);
    std::swap(trunip_, other->trunip_);
    std::swap(trunchannel_, other->trunchannel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TurnResp::GetTypeName() const {
  return "MGC.TurnResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ByeReq::kFromFieldNumber;
const int ByeReq::kToFieldNumber;
const int ByeReq::kSuuidFieldNumber;
#endif  // !_MSC_VER

ByeReq::ByeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ByeReq::InitAsDefaultInstance() {
}

ByeReq::ByeReq(const ByeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ByeReq::SharedCtor() {
  _cached_size_ = 0;
  from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ByeReq::~ByeReq() {
  SharedDtor();
}

void ByeReq::SharedDtor() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    delete suuid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ByeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ByeReq& ByeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

ByeReq* ByeReq::default_instance_ = NULL;

ByeReq* ByeReq::New() const {
  return new ByeReq;
}

void ByeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != &::google::protobuf::internal::kEmptyString) {
        from_->clear();
      }
    }
    if (has_to()) {
      if (to_ != &::google::protobuf::internal::kEmptyString) {
        to_->clear();
      }
    }
    if (has_suuid()) {
      if (suuid_ != &::google::protobuf::internal::kEmptyString) {
        suuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ByeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // required string to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_suuid;
        break;
      }

      // required string suuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_suuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_suuid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ByeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from(), output);
  }

  // required string to = 2;
  if (has_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->to(), output);
  }

  // required string suuid = 3;
  if (has_suuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->suuid(), output);
  }

}

int ByeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from());
    }

    // required string to = 2;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to());
    }

    // required string suuid = 3;
    if (has_suuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->suuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ByeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ByeReq*>(&from));
}

void ByeReq::MergeFrom(const ByeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      set_from(from.from());
    }
    if (from.has_to()) {
      set_to(from.to());
    }
    if (from.has_suuid()) {
      set_suuid(from.suuid());
    }
  }
}

void ByeReq::CopyFrom(const ByeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ByeReq::Swap(ByeReq* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(to_, other->to_);
    std::swap(suuid_, other->suuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ByeReq::GetTypeName() const {
  return "MGC.ByeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ByeResp::kRequestFieldNumber;
const int ByeResp::kCodeFieldNumber;
#endif  // !_MSC_VER

ByeResp::ByeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ByeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  request_ = const_cast< ::MGC::ByeReq*>(
      ::MGC::ByeReq::internal_default_instance());
#else
  request_ = const_cast< ::MGC::ByeReq*>(&::MGC::ByeReq::default_instance());
#endif
}

ByeResp::ByeResp(const ByeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ByeResp::SharedCtor() {
  _cached_size_ = 0;
  request_ = NULL;
  code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ByeResp::~ByeResp() {
  SharedDtor();
}

void ByeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete request_;
  }
}

void ByeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ByeResp& ByeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_media_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_media_2eproto();
#endif
  return *default_instance_;
}

ByeResp* ByeResp::default_instance_ = NULL;

ByeResp* ByeResp::New() const {
  return new ByeResp;
}

void ByeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_request()) {
      if (request_ != NULL) request_->::MGC::ByeReq::Clear();
    }
    code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ByeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MGC.ByeReq request = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required uint32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ByeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .MGC.ByeReq request = 1;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->request(), output);
  }

  // required uint32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->code(), output);
  }

}

int ByeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MGC.ByeReq request = 1;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

    // required uint32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ByeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ByeResp*>(&from));
}

void ByeResp::MergeFrom(const ByeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request()) {
      mutable_request()->::MGC::ByeReq::MergeFrom(from.request());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void ByeResp::CopyFrom(const ByeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_request()) {
    if (!this->request().IsInitialized()) return false;
  }
  return true;
}

void ByeResp::Swap(ByeResp* other) {
  if (other != this) {
    std::swap(request_, other->request_);
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ByeResp::GetTypeName() const {
  return "MGC.ByeResp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MGC

// @@protoc_insertion_point(global_scope)
