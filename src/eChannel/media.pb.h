// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: media.proto

#ifndef PROTOBUF_media_2eproto__INCLUDED
#define PROTOBUF_media_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace MGC {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_media_2eproto();
void protobuf_AssignDesc_media_2eproto();
void protobuf_ShutdownFile_media_2eproto();

class Register;
class RegisterResp;
class TurnRelay;
class Candidates;
class Candidates_Candidate;
class InviteReq;
class InviteResp;
class TurnReq;
class TurnResp;
class ByeReq;
class ByeResp;

// ===================================================================

class Register : public ::google::protobuf::MessageLite {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const Register& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Register* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional uint32 expire = 2;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 2;
  inline ::google::protobuf::uint32 expire() const;
  inline void set_expire(::google::protobuf::uint32 value);

  // optional string auth = 3;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 3;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const char* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // @@protoc_insertion_point(class_scope:MGC.Register)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_auth();
  inline void clear_has_auth();

  ::std::string* from_;
  ::std::string* auth_;
  ::google::protobuf::uint32 expire_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class RegisterResp : public ::google::protobuf::MessageLite {
 public:
  RegisterResp();
  virtual ~RegisterResp();

  RegisterResp(const RegisterResp& from);

  inline RegisterResp& operator=(const RegisterResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterResp* other);

  // implements Message ----------------------------------------------

  RegisterResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterResp& from);
  void MergeFrom(const RegisterResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // optional string privateKey = 3;
  inline bool has_privatekey() const;
  inline void clear_privatekey();
  static const int kPrivateKeyFieldNumber = 3;
  inline const ::std::string& privatekey() const;
  inline void set_privatekey(const ::std::string& value);
  inline void set_privatekey(const char* value);
  inline void set_privatekey(const char* value, size_t size);
  inline ::std::string* mutable_privatekey();
  inline ::std::string* release_privatekey();
  inline void set_allocated_privatekey(::std::string* privatekey);

  // @@protoc_insertion_point(class_scope:MGC.RegisterResp)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_privatekey();
  inline void clear_has_privatekey();

  ::std::string* from_;
  ::std::string* privatekey_;
  ::google::protobuf::uint32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static RegisterResp* default_instance_;
};
// -------------------------------------------------------------------

class TurnRelay : public ::google::protobuf::MessageLite {
 public:
  TurnRelay();
  virtual ~TurnRelay();

  TurnRelay(const TurnRelay& from);

  inline TurnRelay& operator=(const TurnRelay& from) {
    CopyFrom(from);
    return *this;
  }

  static const TurnRelay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TurnRelay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TurnRelay* other);

  // implements Message ----------------------------------------------

  TurnRelay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TurnRelay& from);
  void MergeFrom(const TurnRelay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MGC.TurnRelay)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string* addr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static TurnRelay* default_instance_;
};
// -------------------------------------------------------------------

class Candidates_Candidate : public ::google::protobuf::MessageLite {
 public:
  Candidates_Candidate();
  virtual ~Candidates_Candidate();

  Candidates_Candidate(const Candidates_Candidate& from);

  inline Candidates_Candidate& operator=(const Candidates_Candidate& from) {
    CopyFrom(from);
    return *this;
  }

  static const Candidates_Candidate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Candidates_Candidate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Candidates_Candidate* other);

  // implements Message ----------------------------------------------

  Candidates_Candidate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Candidates_Candidate& from);
  void MergeFrom(const Candidates_Candidate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline ::google::protobuf::uint32 addr() const;
  inline void set_addr(::google::protobuf::uint32 value);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MGC.Candidates.Candidate)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static Candidates_Candidate* default_instance_;
};
// -------------------------------------------------------------------

class Candidates : public ::google::protobuf::MessageLite {
 public:
  Candidates();
  virtual ~Candidates();

  Candidates(const Candidates& from);

  inline Candidates& operator=(const Candidates& from) {
    CopyFrom(from);
    return *this;
  }

  static const Candidates& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Candidates* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Candidates* other);

  // implements Message ----------------------------------------------

  Candidates* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Candidates& from);
  void MergeFrom(const Candidates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Candidates_Candidate Candidate;

  // accessors -------------------------------------------------------

  // required .MGC.Candidates.Candidate nat = 1;
  inline bool has_nat() const;
  inline void clear_nat();
  static const int kNatFieldNumber = 1;
  inline const ::MGC::Candidates_Candidate& nat() const;
  inline ::MGC::Candidates_Candidate* mutable_nat();
  inline ::MGC::Candidates_Candidate* release_nat();
  inline void set_allocated_nat(::MGC::Candidates_Candidate* nat);

  // repeated .MGC.Candidates.Candidate addrs = 2;
  inline int addrs_size() const;
  inline void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  inline const ::MGC::Candidates_Candidate& addrs(int index) const;
  inline ::MGC::Candidates_Candidate* mutable_addrs(int index);
  inline ::MGC::Candidates_Candidate* add_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::MGC::Candidates_Candidate >&
      addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::MGC::Candidates_Candidate >*
      mutable_addrs();

  // @@protoc_insertion_point(class_scope:MGC.Candidates)
 private:
  inline void set_has_nat();
  inline void clear_has_nat();

  ::MGC::Candidates_Candidate* nat_;
  ::google::protobuf::RepeatedPtrField< ::MGC::Candidates_Candidate > addrs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static Candidates* default_instance_;
};
// -------------------------------------------------------------------

class InviteReq : public ::google::protobuf::MessageLite {
 public:
  InviteReq();
  virtual ~InviteReq();

  InviteReq(const InviteReq& from);

  inline InviteReq& operator=(const InviteReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const InviteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteReq* other);

  // implements Message ----------------------------------------------

  InviteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteReq& from);
  void MergeFrom(const InviteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // required string suuid = 3;
  inline bool has_suuid() const;
  inline void clear_suuid();
  static const int kSuuidFieldNumber = 3;
  inline const ::std::string& suuid() const;
  inline void set_suuid(const ::std::string& value);
  inline void set_suuid(const char* value);
  inline void set_suuid(const char* value, size_t size);
  inline ::std::string* mutable_suuid();
  inline ::std::string* release_suuid();
  inline void set_allocated_suuid(::std::string* suuid);

  // optional string mediaAddrs = 4;
  inline bool has_mediaaddrs() const;
  inline void clear_mediaaddrs();
  static const int kMediaAddrsFieldNumber = 4;
  inline const ::std::string& mediaaddrs() const;
  inline void set_mediaaddrs(const ::std::string& value);
  inline void set_mediaaddrs(const char* value);
  inline void set_mediaaddrs(const char* value, size_t size);
  inline ::std::string* mutable_mediaaddrs();
  inline ::std::string* release_mediaaddrs();
  inline void set_allocated_mediaaddrs(::std::string* mediaaddrs);

  // optional uint32 media = 5;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 5;
  inline ::google::protobuf::uint32 media() const;
  inline void set_media(::google::protobuf::uint32 value);

  // optional string mediaInfo = 6;
  inline bool has_mediainfo() const;
  inline void clear_mediainfo();
  static const int kMediaInfoFieldNumber = 6;
  inline const ::std::string& mediainfo() const;
  inline void set_mediainfo(const ::std::string& value);
  inline void set_mediainfo(const char* value);
  inline void set_mediainfo(const char* value, size_t size);
  inline ::std::string* mutable_mediainfo();
  inline ::std::string* release_mediainfo();
  inline void set_allocated_mediainfo(::std::string* mediainfo);

  // optional uint32 transport = 7;
  inline bool has_transport() const;
  inline void clear_transport();
  static const int kTransportFieldNumber = 7;
  inline ::google::protobuf::uint32 transport() const;
  inline void set_transport(::google::protobuf::uint32 value);

  // repeated .MGC.TurnRelay turnaddr = 8;
  inline int turnaddr_size() const;
  inline void clear_turnaddr();
  static const int kTurnaddrFieldNumber = 8;
  inline const ::MGC::TurnRelay& turnaddr(int index) const;
  inline ::MGC::TurnRelay* mutable_turnaddr(int index);
  inline ::MGC::TurnRelay* add_turnaddr();
  inline const ::google::protobuf::RepeatedPtrField< ::MGC::TurnRelay >&
      turnaddr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MGC::TurnRelay >*
      mutable_turnaddr();

  // @@protoc_insertion_point(class_scope:MGC.InviteReq)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_suuid();
  inline void clear_has_suuid();
  inline void set_has_mediaaddrs();
  inline void clear_has_mediaaddrs();
  inline void set_has_media();
  inline void clear_has_media();
  inline void set_has_mediainfo();
  inline void clear_has_mediainfo();
  inline void set_has_transport();
  inline void clear_has_transport();

  ::std::string* from_;
  ::std::string* to_;
  ::std::string* suuid_;
  ::std::string* mediaaddrs_;
  ::std::string* mediainfo_;
  ::google::protobuf::uint32 media_;
  ::google::protobuf::uint32 transport_;
  ::google::protobuf::RepeatedPtrField< ::MGC::TurnRelay > turnaddr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static InviteReq* default_instance_;
};
// -------------------------------------------------------------------

class InviteResp : public ::google::protobuf::MessageLite {
 public:
  InviteResp();
  virtual ~InviteResp();

  InviteResp(const InviteResp& from);

  inline InviteResp& operator=(const InviteResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const InviteResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteResp* other);

  // implements Message ----------------------------------------------

  InviteResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteResp& from);
  void MergeFrom(const InviteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MGC.InviteReq request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::MGC::InviteReq& request() const;
  inline ::MGC::InviteReq* mutable_request();
  inline ::MGC::InviteReq* release_request();
  inline void set_allocated_request(::MGC::InviteReq* request);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MGC.InviteResp)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_code();
  inline void clear_has_code();

  ::MGC::InviteReq* request_;
  ::google::protobuf::uint32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static InviteResp* default_instance_;
};
// -------------------------------------------------------------------

class TurnReq : public ::google::protobuf::MessageLite {
 public:
  TurnReq();
  virtual ~TurnReq();

  TurnReq(const TurnReq& from);

  inline TurnReq& operator=(const TurnReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const TurnReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TurnReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TurnReq* other);

  // implements Message ----------------------------------------------

  TurnReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TurnReq& from);
  void MergeFrom(const TurnReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required string from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // @@protoc_insertion_point(class_scope:MGC.TurnReq)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_from();
  inline void clear_has_from();

  ::std::string* uuid_;
  ::std::string* from_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static TurnReq* default_instance_;
};
// -------------------------------------------------------------------

class TurnResp : public ::google::protobuf::MessageLite {
 public:
  TurnResp();
  virtual ~TurnResp();

  TurnResp(const TurnResp& from);

  inline TurnResp& operator=(const TurnResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TurnResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TurnResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TurnResp* other);

  // implements Message ----------------------------------------------

  TurnResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TurnResp& from);
  void MergeFrom(const TurnResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MGC.TurnReq request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::MGC::TurnReq& request() const;
  inline ::MGC::TurnReq* mutable_request();
  inline ::MGC::TurnReq* release_request();
  inline void set_allocated_request(::MGC::TurnReq* request);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // optional string TrunIp = 3;
  inline bool has_trunip() const;
  inline void clear_trunip();
  static const int kTrunIpFieldNumber = 3;
  inline const ::std::string& trunip() const;
  inline void set_trunip(const ::std::string& value);
  inline void set_trunip(const char* value);
  inline void set_trunip(const char* value, size_t size);
  inline ::std::string* mutable_trunip();
  inline ::std::string* release_trunip();
  inline void set_allocated_trunip(::std::string* trunip);

  // optional uint32 TrunChannel = 4;
  inline bool has_trunchannel() const;
  inline void clear_trunchannel();
  static const int kTrunChannelFieldNumber = 4;
  inline ::google::protobuf::uint32 trunchannel() const;
  inline void set_trunchannel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MGC.TurnResp)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_trunip();
  inline void clear_has_trunip();
  inline void set_has_trunchannel();
  inline void clear_has_trunchannel();

  ::MGC::TurnReq* request_;
  ::std::string* trunip_;
  ::google::protobuf::uint32 code_;
  ::google::protobuf::uint32 trunchannel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static TurnResp* default_instance_;
};
// -------------------------------------------------------------------

class ByeReq : public ::google::protobuf::MessageLite {
 public:
  ByeReq();
  virtual ~ByeReq();

  ByeReq(const ByeReq& from);

  inline ByeReq& operator=(const ByeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ByeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ByeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ByeReq* other);

  // implements Message ----------------------------------------------

  ByeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ByeReq& from);
  void MergeFrom(const ByeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // required string suuid = 3;
  inline bool has_suuid() const;
  inline void clear_suuid();
  static const int kSuuidFieldNumber = 3;
  inline const ::std::string& suuid() const;
  inline void set_suuid(const ::std::string& value);
  inline void set_suuid(const char* value);
  inline void set_suuid(const char* value, size_t size);
  inline ::std::string* mutable_suuid();
  inline ::std::string* release_suuid();
  inline void set_allocated_suuid(::std::string* suuid);

  // @@protoc_insertion_point(class_scope:MGC.ByeReq)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_suuid();
  inline void clear_has_suuid();

  ::std::string* from_;
  ::std::string* to_;
  ::std::string* suuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static ByeReq* default_instance_;
};
// -------------------------------------------------------------------

class ByeResp : public ::google::protobuf::MessageLite {
 public:
  ByeResp();
  virtual ~ByeResp();

  ByeResp(const ByeResp& from);

  inline ByeResp& operator=(const ByeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ByeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ByeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ByeResp* other);

  // implements Message ----------------------------------------------

  ByeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ByeResp& from);
  void MergeFrom(const ByeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MGC.ByeReq request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::MGC::ByeReq& request() const;
  inline ::MGC::ByeReq* mutable_request();
  inline ::MGC::ByeReq* release_request();
  inline void set_allocated_request(::MGC::ByeReq* request);

  // required uint32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MGC.ByeResp)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_code();
  inline void clear_has_code();

  ::MGC::ByeReq* request_;
  ::google::protobuf::uint32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_media_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_media_2eproto();
  #endif
  friend void protobuf_AssignDesc_media_2eproto();
  friend void protobuf_ShutdownFile_media_2eproto();

  void InitAsDefaultInstance();
  static ByeResp* default_instance_;
};
// ===================================================================


// ===================================================================

// Register

// required string from = 1;
inline bool Register::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Register::from() const {
  return *from_;
}
inline void Register::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Register::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Register::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Register::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 expire = 2;
inline bool Register::has_expire() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_expire() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_expire() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_expire() {
  expire_ = 0u;
  clear_has_expire();
}
inline ::google::protobuf::uint32 Register::expire() const {
  return expire_;
}
inline void Register::set_expire(::google::protobuf::uint32 value) {
  set_has_expire();
  expire_ = value;
}

// optional string auth = 3;
inline bool Register::has_auth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_auth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_auth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_auth() {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& Register::auth() const {
  return *auth_;
}
inline void Register::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void Register::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void Register::set_auth(const char* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  return auth_;
}
inline ::std::string* Register::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Register::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterResp

// required string from = 1;
inline bool RegisterResp::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResp::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResp::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResp::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& RegisterResp::from() const {
  return *from_;
}
inline void RegisterResp::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void RegisterResp::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void RegisterResp::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterResp::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* RegisterResp::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterResp::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 code = 2;
inline bool RegisterResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResp::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 RegisterResp::code() const {
  return code_;
}
inline void RegisterResp::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// optional string privateKey = 3;
inline bool RegisterResp::has_privatekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterResp::set_has_privatekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterResp::clear_has_privatekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterResp::clear_privatekey() {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    privatekey_->clear();
  }
  clear_has_privatekey();
}
inline const ::std::string& RegisterResp::privatekey() const {
  return *privatekey_;
}
inline void RegisterResp::set_privatekey(const ::std::string& value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void RegisterResp::set_privatekey(const char* value) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(value);
}
inline void RegisterResp::set_privatekey(const char* value, size_t size) {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  privatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterResp::mutable_privatekey() {
  set_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    privatekey_ = new ::std::string;
  }
  return privatekey_;
}
inline ::std::string* RegisterResp::release_privatekey() {
  clear_has_privatekey();
  if (privatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = privatekey_;
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterResp::set_allocated_privatekey(::std::string* privatekey) {
  if (privatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete privatekey_;
  }
  if (privatekey) {
    set_has_privatekey();
    privatekey_ = privatekey;
  } else {
    clear_has_privatekey();
    privatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TurnRelay

// required string addr = 1;
inline bool TurnRelay::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TurnRelay::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TurnRelay::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TurnRelay::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& TurnRelay::addr() const {
  return *addr_;
}
inline void TurnRelay::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void TurnRelay::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void TurnRelay::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TurnRelay::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* TurnRelay::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TurnRelay::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 port = 2;
inline bool TurnRelay::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TurnRelay::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TurnRelay::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TurnRelay::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TurnRelay::port() const {
  return port_;
}
inline void TurnRelay::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Candidates_Candidate

// required uint32 addr = 1;
inline bool Candidates_Candidate::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates_Candidate::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates_Candidate::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates_Candidate::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 Candidates_Candidate::addr() const {
  return addr_;
}
inline void Candidates_Candidate::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
}

// required uint32 port = 2;
inline bool Candidates_Candidate::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidates_Candidate::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidates_Candidate::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidates_Candidate::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 Candidates_Candidate::port() const {
  return port_;
}
inline void Candidates_Candidate::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Candidates

// required .MGC.Candidates.Candidate nat = 1;
inline bool Candidates::has_nat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates::set_has_nat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates::clear_has_nat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates::clear_nat() {
  if (nat_ != NULL) nat_->::MGC::Candidates_Candidate::Clear();
  clear_has_nat();
}
inline const ::MGC::Candidates_Candidate& Candidates::nat() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nat_ != NULL ? *nat_ : *default_instance().nat_;
#else
  return nat_ != NULL ? *nat_ : *default_instance_->nat_;
#endif
}
inline ::MGC::Candidates_Candidate* Candidates::mutable_nat() {
  set_has_nat();
  if (nat_ == NULL) nat_ = new ::MGC::Candidates_Candidate;
  return nat_;
}
inline ::MGC::Candidates_Candidate* Candidates::release_nat() {
  clear_has_nat();
  ::MGC::Candidates_Candidate* temp = nat_;
  nat_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_nat(::MGC::Candidates_Candidate* nat) {
  delete nat_;
  nat_ = nat;
  if (nat) {
    set_has_nat();
  } else {
    clear_has_nat();
  }
}

// repeated .MGC.Candidates.Candidate addrs = 2;
inline int Candidates::addrs_size() const {
  return addrs_.size();
}
inline void Candidates::clear_addrs() {
  addrs_.Clear();
}
inline const ::MGC::Candidates_Candidate& Candidates::addrs(int index) const {
  return addrs_.Get(index);
}
inline ::MGC::Candidates_Candidate* Candidates::mutable_addrs(int index) {
  return addrs_.Mutable(index);
}
inline ::MGC::Candidates_Candidate* Candidates::add_addrs() {
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MGC::Candidates_Candidate >&
Candidates::addrs() const {
  return addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::MGC::Candidates_Candidate >*
Candidates::mutable_addrs() {
  return &addrs_;
}

// -------------------------------------------------------------------

// InviteReq

// required string from = 1;
inline bool InviteReq::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteReq::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteReq::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteReq::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& InviteReq::from() const {
  return *from_;
}
inline void InviteReq::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void InviteReq::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void InviteReq::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteReq::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* InviteReq::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteReq::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 2;
inline bool InviteReq::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteReq::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteReq::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteReq::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& InviteReq::to() const {
  return *to_;
}
inline void InviteReq::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void InviteReq::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void InviteReq::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteReq::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* InviteReq::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteReq::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string suuid = 3;
inline bool InviteReq::has_suuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteReq::set_has_suuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteReq::clear_has_suuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteReq::clear_suuid() {
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    suuid_->clear();
  }
  clear_has_suuid();
}
inline const ::std::string& InviteReq::suuid() const {
  return *suuid_;
}
inline void InviteReq::set_suuid(const ::std::string& value) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(value);
}
inline void InviteReq::set_suuid(const char* value) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(value);
}
inline void InviteReq::set_suuid(const char* value, size_t size) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteReq::mutable_suuid() {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  return suuid_;
}
inline ::std::string* InviteReq::release_suuid() {
  clear_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suuid_;
    suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteReq::set_allocated_suuid(::std::string* suuid) {
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    delete suuid_;
  }
  if (suuid) {
    set_has_suuid();
    suuid_ = suuid;
  } else {
    clear_has_suuid();
    suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mediaAddrs = 4;
inline bool InviteReq::has_mediaaddrs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteReq::set_has_mediaaddrs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteReq::clear_has_mediaaddrs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteReq::clear_mediaaddrs() {
  if (mediaaddrs_ != &::google::protobuf::internal::kEmptyString) {
    mediaaddrs_->clear();
  }
  clear_has_mediaaddrs();
}
inline const ::std::string& InviteReq::mediaaddrs() const {
  return *mediaaddrs_;
}
inline void InviteReq::set_mediaaddrs(const ::std::string& value) {
  set_has_mediaaddrs();
  if (mediaaddrs_ == &::google::protobuf::internal::kEmptyString) {
    mediaaddrs_ = new ::std::string;
  }
  mediaaddrs_->assign(value);
}
inline void InviteReq::set_mediaaddrs(const char* value) {
  set_has_mediaaddrs();
  if (mediaaddrs_ == &::google::protobuf::internal::kEmptyString) {
    mediaaddrs_ = new ::std::string;
  }
  mediaaddrs_->assign(value);
}
inline void InviteReq::set_mediaaddrs(const char* value, size_t size) {
  set_has_mediaaddrs();
  if (mediaaddrs_ == &::google::protobuf::internal::kEmptyString) {
    mediaaddrs_ = new ::std::string;
  }
  mediaaddrs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteReq::mutable_mediaaddrs() {
  set_has_mediaaddrs();
  if (mediaaddrs_ == &::google::protobuf::internal::kEmptyString) {
    mediaaddrs_ = new ::std::string;
  }
  return mediaaddrs_;
}
inline ::std::string* InviteReq::release_mediaaddrs() {
  clear_has_mediaaddrs();
  if (mediaaddrs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediaaddrs_;
    mediaaddrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteReq::set_allocated_mediaaddrs(::std::string* mediaaddrs) {
  if (mediaaddrs_ != &::google::protobuf::internal::kEmptyString) {
    delete mediaaddrs_;
  }
  if (mediaaddrs) {
    set_has_mediaaddrs();
    mediaaddrs_ = mediaaddrs;
  } else {
    clear_has_mediaaddrs();
    mediaaddrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 media = 5;
inline bool InviteReq::has_media() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InviteReq::set_has_media() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InviteReq::clear_has_media() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InviteReq::clear_media() {
  media_ = 0u;
  clear_has_media();
}
inline ::google::protobuf::uint32 InviteReq::media() const {
  return media_;
}
inline void InviteReq::set_media(::google::protobuf::uint32 value) {
  set_has_media();
  media_ = value;
}

// optional string mediaInfo = 6;
inline bool InviteReq::has_mediainfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InviteReq::set_has_mediainfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InviteReq::clear_has_mediainfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InviteReq::clear_mediainfo() {
  if (mediainfo_ != &::google::protobuf::internal::kEmptyString) {
    mediainfo_->clear();
  }
  clear_has_mediainfo();
}
inline const ::std::string& InviteReq::mediainfo() const {
  return *mediainfo_;
}
inline void InviteReq::set_mediainfo(const ::std::string& value) {
  set_has_mediainfo();
  if (mediainfo_ == &::google::protobuf::internal::kEmptyString) {
    mediainfo_ = new ::std::string;
  }
  mediainfo_->assign(value);
}
inline void InviteReq::set_mediainfo(const char* value) {
  set_has_mediainfo();
  if (mediainfo_ == &::google::protobuf::internal::kEmptyString) {
    mediainfo_ = new ::std::string;
  }
  mediainfo_->assign(value);
}
inline void InviteReq::set_mediainfo(const char* value, size_t size) {
  set_has_mediainfo();
  if (mediainfo_ == &::google::protobuf::internal::kEmptyString) {
    mediainfo_ = new ::std::string;
  }
  mediainfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteReq::mutable_mediainfo() {
  set_has_mediainfo();
  if (mediainfo_ == &::google::protobuf::internal::kEmptyString) {
    mediainfo_ = new ::std::string;
  }
  return mediainfo_;
}
inline ::std::string* InviteReq::release_mediainfo() {
  clear_has_mediainfo();
  if (mediainfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediainfo_;
    mediainfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteReq::set_allocated_mediainfo(::std::string* mediainfo) {
  if (mediainfo_ != &::google::protobuf::internal::kEmptyString) {
    delete mediainfo_;
  }
  if (mediainfo) {
    set_has_mediainfo();
    mediainfo_ = mediainfo;
  } else {
    clear_has_mediainfo();
    mediainfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 transport = 7;
inline bool InviteReq::has_transport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InviteReq::set_has_transport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InviteReq::clear_has_transport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InviteReq::clear_transport() {
  transport_ = 0u;
  clear_has_transport();
}
inline ::google::protobuf::uint32 InviteReq::transport() const {
  return transport_;
}
inline void InviteReq::set_transport(::google::protobuf::uint32 value) {
  set_has_transport();
  transport_ = value;
}

// repeated .MGC.TurnRelay turnaddr = 8;
inline int InviteReq::turnaddr_size() const {
  return turnaddr_.size();
}
inline void InviteReq::clear_turnaddr() {
  turnaddr_.Clear();
}
inline const ::MGC::TurnRelay& InviteReq::turnaddr(int index) const {
  return turnaddr_.Get(index);
}
inline ::MGC::TurnRelay* InviteReq::mutable_turnaddr(int index) {
  return turnaddr_.Mutable(index);
}
inline ::MGC::TurnRelay* InviteReq::add_turnaddr() {
  return turnaddr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MGC::TurnRelay >&
InviteReq::turnaddr() const {
  return turnaddr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MGC::TurnRelay >*
InviteReq::mutable_turnaddr() {
  return &turnaddr_;
}

// -------------------------------------------------------------------

// InviteResp

// required .MGC.InviteReq request = 1;
inline bool InviteResp::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteResp::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteResp::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteResp::clear_request() {
  if (request_ != NULL) request_->::MGC::InviteReq::Clear();
  clear_has_request();
}
inline const ::MGC::InviteReq& InviteResp::request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_ != NULL ? *request_ : *default_instance().request_;
#else
  return request_ != NULL ? *request_ : *default_instance_->request_;
#endif
}
inline ::MGC::InviteReq* InviteResp::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::MGC::InviteReq;
  return request_;
}
inline ::MGC::InviteReq* InviteResp::release_request() {
  clear_has_request();
  ::MGC::InviteReq* temp = request_;
  request_ = NULL;
  return temp;
}
inline void InviteResp::set_allocated_request(::MGC::InviteReq* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// required uint32 code = 2;
inline bool InviteResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteResp::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 InviteResp::code() const {
  return code_;
}
inline void InviteResp::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// TurnReq

// required string uuid = 1;
inline bool TurnReq::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TurnReq::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TurnReq::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TurnReq::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& TurnReq::uuid() const {
  return *uuid_;
}
inline void TurnReq::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void TurnReq::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void TurnReq::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TurnReq::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* TurnReq::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TurnReq::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string from = 2;
inline bool TurnReq::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TurnReq::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TurnReq::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TurnReq::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& TurnReq::from() const {
  return *from_;
}
inline void TurnReq::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void TurnReq::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void TurnReq::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TurnReq::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* TurnReq::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TurnReq::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TurnResp

// required .MGC.TurnReq request = 1;
inline bool TurnResp::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TurnResp::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TurnResp::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TurnResp::clear_request() {
  if (request_ != NULL) request_->::MGC::TurnReq::Clear();
  clear_has_request();
}
inline const ::MGC::TurnReq& TurnResp::request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_ != NULL ? *request_ : *default_instance().request_;
#else
  return request_ != NULL ? *request_ : *default_instance_->request_;
#endif
}
inline ::MGC::TurnReq* TurnResp::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::MGC::TurnReq;
  return request_;
}
inline ::MGC::TurnReq* TurnResp::release_request() {
  clear_has_request();
  ::MGC::TurnReq* temp = request_;
  request_ = NULL;
  return temp;
}
inline void TurnResp::set_allocated_request(::MGC::TurnReq* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// required uint32 code = 2;
inline bool TurnResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TurnResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TurnResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TurnResp::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 TurnResp::code() const {
  return code_;
}
inline void TurnResp::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// optional string TrunIp = 3;
inline bool TurnResp::has_trunip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TurnResp::set_has_trunip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TurnResp::clear_has_trunip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TurnResp::clear_trunip() {
  if (trunip_ != &::google::protobuf::internal::kEmptyString) {
    trunip_->clear();
  }
  clear_has_trunip();
}
inline const ::std::string& TurnResp::trunip() const {
  return *trunip_;
}
inline void TurnResp::set_trunip(const ::std::string& value) {
  set_has_trunip();
  if (trunip_ == &::google::protobuf::internal::kEmptyString) {
    trunip_ = new ::std::string;
  }
  trunip_->assign(value);
}
inline void TurnResp::set_trunip(const char* value) {
  set_has_trunip();
  if (trunip_ == &::google::protobuf::internal::kEmptyString) {
    trunip_ = new ::std::string;
  }
  trunip_->assign(value);
}
inline void TurnResp::set_trunip(const char* value, size_t size) {
  set_has_trunip();
  if (trunip_ == &::google::protobuf::internal::kEmptyString) {
    trunip_ = new ::std::string;
  }
  trunip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TurnResp::mutable_trunip() {
  set_has_trunip();
  if (trunip_ == &::google::protobuf::internal::kEmptyString) {
    trunip_ = new ::std::string;
  }
  return trunip_;
}
inline ::std::string* TurnResp::release_trunip() {
  clear_has_trunip();
  if (trunip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trunip_;
    trunip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TurnResp::set_allocated_trunip(::std::string* trunip) {
  if (trunip_ != &::google::protobuf::internal::kEmptyString) {
    delete trunip_;
  }
  if (trunip) {
    set_has_trunip();
    trunip_ = trunip;
  } else {
    clear_has_trunip();
    trunip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TrunChannel = 4;
inline bool TurnResp::has_trunchannel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TurnResp::set_has_trunchannel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TurnResp::clear_has_trunchannel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TurnResp::clear_trunchannel() {
  trunchannel_ = 0u;
  clear_has_trunchannel();
}
inline ::google::protobuf::uint32 TurnResp::trunchannel() const {
  return trunchannel_;
}
inline void TurnResp::set_trunchannel(::google::protobuf::uint32 value) {
  set_has_trunchannel();
  trunchannel_ = value;
}

// -------------------------------------------------------------------

// ByeReq

// required string from = 1;
inline bool ByeReq::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByeReq::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ByeReq::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ByeReq::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& ByeReq::from() const {
  return *from_;
}
inline void ByeReq::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ByeReq::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ByeReq::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ByeReq::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* ByeReq::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ByeReq::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 2;
inline bool ByeReq::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ByeReq::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ByeReq::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ByeReq::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& ByeReq::to() const {
  return *to_;
}
inline void ByeReq::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ByeReq::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ByeReq::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ByeReq::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* ByeReq::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ByeReq::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string suuid = 3;
inline bool ByeReq::has_suuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ByeReq::set_has_suuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ByeReq::clear_has_suuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ByeReq::clear_suuid() {
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    suuid_->clear();
  }
  clear_has_suuid();
}
inline const ::std::string& ByeReq::suuid() const {
  return *suuid_;
}
inline void ByeReq::set_suuid(const ::std::string& value) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(value);
}
inline void ByeReq::set_suuid(const char* value) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(value);
}
inline void ByeReq::set_suuid(const char* value, size_t size) {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  suuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ByeReq::mutable_suuid() {
  set_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    suuid_ = new ::std::string;
  }
  return suuid_;
}
inline ::std::string* ByeReq::release_suuid() {
  clear_has_suuid();
  if (suuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suuid_;
    suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ByeReq::set_allocated_suuid(::std::string* suuid) {
  if (suuid_ != &::google::protobuf::internal::kEmptyString) {
    delete suuid_;
  }
  if (suuid) {
    set_has_suuid();
    suuid_ = suuid;
  } else {
    clear_has_suuid();
    suuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ByeResp

// required .MGC.ByeReq request = 1;
inline bool ByeResp::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByeResp::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ByeResp::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ByeResp::clear_request() {
  if (request_ != NULL) request_->::MGC::ByeReq::Clear();
  clear_has_request();
}
inline const ::MGC::ByeReq& ByeResp::request() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return request_ != NULL ? *request_ : *default_instance().request_;
#else
  return request_ != NULL ? *request_ : *default_instance_->request_;
#endif
}
inline ::MGC::ByeReq* ByeResp::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::MGC::ByeReq;
  return request_;
}
inline ::MGC::ByeReq* ByeResp::release_request() {
  clear_has_request();
  ::MGC::ByeReq* temp = request_;
  request_ = NULL;
  return temp;
}
inline void ByeResp::set_allocated_request(::MGC::ByeReq* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// required uint32 code = 2;
inline bool ByeResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ByeResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ByeResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ByeResp::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 ByeResp::code() const {
  return code_;
}
inline void ByeResp::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MGC

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_media_2eproto__INCLUDED
